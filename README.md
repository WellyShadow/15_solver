# Алгоритмы. Вариант 38
###### дисклеймер: код чтобы чисто посмотреть будет работать или нет, там ошибка в алгоритме (больше похоже не на А star, а на поиск в ширину с блекджеком и эвристиками), и куча ошибок в с++. вообще смотреть пока не надо, он тут чтобы я с другой машины имел доступ.

## Задача
Постройте программу для решения головоломки «Пятнашки»
произвольного размера. 

---
## Разбор задачи
[Доказательство NP полноты](https://www.aaai.org/Papers/AAAI/1986/AAAI86-027.pdf)
для кратчайшего решения пятнашек размерности n.

### Проверка на существование решения
Я пока этим не занимался, но здесь должны быть какие то умные слова про чётное и нечётное число инверсий и ссылка на длинное доказательство на английском.


### Решение

Весь процесс поиска решения в "Пятнашках" можно представить как задачу поиска на графе. Вершинами такого графа будут состояния поля головоломки, полученные в результате перемещения костяшек.

Поиск решения можно свести к поиску терминального состояния игрового поля (обычно, в качестве терминальной, выбирается расстановка костяшек, упорядоченных по возрастанию слева направо, сверху вниз - 1,2,3,... ).

Для решения задачи поиска терминальной вершины на графе можно использовать алгоритмы полного перебора (поиск в глубину или ширину), но количество возможных решений (возможных перестановок) скорее всего окажется слишком большим.

## Алгоритм A*

Алгоритм A* позволяет существенно сократить количество состояний для перебора, путем применения некоторой дополнительной информации - эвристики. В качестве такой информации для пятнашек я возьму несколько эвристик описанных ниже.

Алгоритм A* предполагает наличие двух списков вершин графа: открытого и закрытого. В первом находятся вершины, еще не проверенные алгоритмом, а во втором те вершины, которые уже встречались в ходе поиска решения.

На каждом новом шаге, из списка открытых вершин выбирается вершина с наименьшим весом (поэтому использовалась очередь). Вес (F) каждой вершины вычисляется как сумма расстояния от начальной вершины до текущей (G) и эвристическое предположение о расстоянии от текущей вершины, до терминальной (H).

**Fi = Gi + Hi**, где i - текущая вершина (состояние игрового поля).

## Эвристики
Все эвристики будут рассмотрены на примере пятнашек размерности 3, но так же являются верными и для размерности n.

После непродолжительного поиска, было принято решение взять за основу сумму следующих эвристик:

### Manhattan distance

Функция: ***manh_distance()***


Основная эвристика, это сумма расстояний по строкам и столбцам от текущего расположения костяшки до ее правильной позиции. 
Допустимость следует из того, что за один ход перемещается только одна фишка, и расстояние между этой фишкой и её конечной позицией изменяется на 1

Пример:

| **1** | **2** | **3** |  
--- | --- | ---
| **6** | **5** | **4** | 
| **7** | **8** |  |

***this->manh_distance()*** // == 4

### Linear conflict

Функция: ***linear_conflict()***

Костяшка I и костяшка J находятся в линейном конфликте по строке, если они обе стоят в своей строке, но костяшка I находится левее костяшки J, хотя на самом деле должна быть справа. Мы должны подвинуть одну из костяшек со строки, поэтому можем добавить 2 к общей эвристике. Аналогичным образом рассматривается линейный конфликт по столбцу. Правый нижний угол в эвристике не рассматривается, так как очень сложно скомбинировать этот случай с **last_move**.

Пример:

| **2** | **1** | **k** |  
--- | --- | ---
| **k** | **k** | **k** | 
| **k** | **k** | **k** |

***this->manh_distance()*** // H + 2

### Corner tiles

Функция: ***corner_tiles()***

Пусть на месте 1 стоит любая другая костяшка, а один из её соседей (или оба), 
уже выставлен на своё место, тогда чтобы поставить единицу на место соседей придётся подвинуть. Прибавляем 2 к общей эвристике. Если соседи уже участвуют в **linear_conflict**, то всё учтено и 2 добавлять уже не нужно.

Пример:

| **!1** | **2** | **k** |  
--- | --- | ---
| **k** | **k** | **k** | 
| **k** | **k** | **k** |

| **!1** | **k** | **k** |
--- | --- | ---
| **4** | **k** | **k** | 
| **k** | **k** | **k** |

**this->corner_tiles()** // == H + 2 в обоих случаях

### Last move

Функция: ***last_move()***

На последнем ходу у нас есть два варианта:

| **1** | **2** | **3** |
--- | --- | ---
| **4** | **5** | **6** | 
| **7** |  | **8** |

| **1** | **2** | **3** |
--- | --- | ---
| **4** | **5** |  | Считается, что к
| **7** | **8** | **6** |

**this->last_move()** // == H + 0 в обоих случаях, при другом расположении 6 и 8 прибавляем 2.

Если костяшки не находятся на требуемых позициях, манхэттенское расстояние не учитпроверка на сущестывает переход через угол. Следовательно, мы можем добавить к нему 2.

## Формат входных и выходных данных
На вход первой строкой размерность, а дальше чисто на логике как в пятнашках:
```
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 0
```
На выходе ~~даст бог~~ получим первой строкой число ходов до решения, а далее состоянии доски на каждый ход:
```
353
1 2 3 4
5 6 7 8
9 10 11 12
13 15 14 0
----------
1 2 3 4
5 6 7 8
9 10 11 12
13 15 0 14
...
...
...
```

 ... либо:
 ``` NO SOLUTION FOR YOUR COMBINATION```

## План
1. Написать проверку на сущ. решения
2. Переписать корявый код на умных указателях
3. Подправить алгоритм, чтобы получилось 'А звёздочка'
4. Дописать эвристики (но с одной тож норм)
5. Вынести и шаблонизировать алгоритм, для применения для любой другой задачи на поиск по графу.

Также, буду юзать:
- ~~Python~~ C++
- **priority_queue** из stl с переопределенным компаратором
- **hash** из std который будет делать уникальный хэш из состояния доски для отметки вершины в посещённых
- Бесконечный **while**
- Хранить доску в простом массиве, так проще
- Другие нестандартные приёмы и новшества...

### ToDo list:
- Переписать весь код
- Сделать проверку на наличие решения
- Дописать эвристики
- Юзать смарт поинтеры
- Допилить ввод
- Память пока что не очищается в конце программы
- Всякое такое
- !Hash функция работает неправильно для варика ...1 11... и ...11 1..., переписать с запятыми, будет классно

### Годные ссылки и источники
[раз](https://www.cs.princeton.edu/courses/archive/fall12/cos226/assignments/8puzzle.html)

[два](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)

[три](http://book.etudes.ru/toc/15puzzle/)

[поискать на вики]()

[и в гугле]()