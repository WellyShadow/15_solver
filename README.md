# Алгоритмы. Вариант 38

## Задача
Постройте программу для решения головоломки «Пятнашки»
произвольного размера. 

---
## Разбор задачи
[Доказательство NP полноты](https://www.aaai.org/Papers/AAAI/1986/AAAI86-027.pdf)
для кратчайшего решения пятнашек размерности n.

### Проверка на существование решения
Я пока этим не занимался, но здесь должны быть какие то умные слова про чётное и нечётное число инверсий и ссылка на длинное доказательство на английском.


### Решение

Весь процесс поиска решения в "Пятнашках" можно представить как задачу поиска на графе. Вершинами такого графа будут состояния поля головоломки, полученные в результате перемещения костяшек.

Поиск решения можно свести к поиску терминального состояния игрового поля (обычно, в качестве терминальной, выбирается расстановка костяшек, упорядоченных по возрастанию слева направо, сверху вниз - 1,2,3,... ).

Для решения задачи поиска терминальной вершины на графе можно использовать алгоритмы полного перебора (поиск в глубину или ширину), но количество возможных решений (возможных перестановок) скорее всего окажется слишком большим.


## Алгоритм A*

Алгоритм A* позволяет существенно сократить количество состояний для перебора, путем применения некоторой дополнительной информации - эвристики. В качестве такой информации для пятнашек я возьму несколько эвристик описанных ниже.

Алгоритм A* предполагает наличие двух списков вершин графа: открытого и закрытого. В первом находятся вершины, еще не проверенные алгоритмом, а во втором те вершины, которые уже встречались в ходе поиска решения.

На каждом новом шаге, из списка открытых вершин выбирается вершина с наименьшим весом (поэтому использовалась очередь). Вес (F) каждой вершины вычисляется как сумма расстояния от начальной вершины до текущей (G) и эвристическое предположение о расстоянии от текущей вершины, до терминальной (H).

**Fi = Gi + Hi**, где i - текущая вершина (состояние игрового поля).

## Эвристики
Все эвристики будут рассмотрены на примере пятнашек размерности 3, но так же являются верными и для размерности n.

После непродолжительного поиска, было принято решение взять за основу сумму следующих эвристик:

### Manhattan distance

Функция: ***manh_distance()***


Основная эвристика, это сумма расстояний по строкам и столбцам от текущего расположения костяшки до ее правильной позиции. 
Допустимость следует из того, что за один ход перемещается только одна фишка, и расстояние между этой фишкой и её конечной позицией изменяется на 1

Пример:

| **1** | **2** | **3** |  
--- | --- | ---
| **6** | **5** | **4** | 
| **7** | **8** |  |

***this->manh_distance()*** // == 4

### Linear conflict

Функция: ***linear_conflict()***

Костяшка I и костяшка J находятся в линейном конфликте по строке, если они обе стоят в своей строке, но костяшка I находится левее костяшки J, хотя на самом деле должна быть справа. Мы должны подвинуть одну из костяшек со строки, поэтому можем добавить 2 к общей эвристике. Аналогичным образом рассматривается линейный конфликт по столбцу. Правый нижний угол в эвристике не рассматривается, так как очень сложно скомбинировать этот случай с **last_move**.

Пример:

| **2** | **1** | **k** |  
--- | --- | ---
| **k** | **k** | **k** | 
| **k** | **k** | **k** |

***this->manh_distance()*** // H + 2

### Corner tiles

Функция: ***corner_tiles()***

Пусть на месте 1 стоит любая другая костяшка, а один из её соседей (или оба), 
уже выставлен на своё место, тогда чтобы поставить единицу на место соседей придётся подвинуть. Прибавляем 2 к общей эвристике. Если соседи уже участвуют в **linear_conflict**, то всё учтено и 2 добавлять уже не нужно.

Пример:

| **!1** | **2** | **k** |  
--- | --- | ---
| **k** | **k** | **k** | 
| **k** | **k** | **k** |

| **!1** | **k** | **k** |
--- | --- | ---
| **4** | **k** | **k** | 
| **k** | **k** | **k** |

**this->corner_tiles()** // == H + 2 в обоих случаях

### Last move

Функция: ***last_move()***

На последнем ходу у нас есть два варианта:

| **1** | **2** | **3** |
--- | --- | ---
| **4** | **5** | **6** | 
| **7** |  | **8** |

| **1** | **2** | **3** |
--- | --- | ---
| **4** | **5** |  | Считается, что к
| **7** | **8** | **6** |

**this->last_move()** // == H + 0 в обоих случаях, при другом расположении 6 и 8 прибавляем 2.

Если костяшки не находятся на требуемых позициях, манхэттенское расстояние не учитпроверка на сущестывает переход через угол. Следовательно, мы можем добавить к нему 2.

## Формат входных и выходных данных
На вход первой строкой размерность, а дальше чисто на логике как в пятнашках:
```
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 0
```
На выходе ~~даст бог~~ получим первой строкой число ходов до решения, а далее состоянии доски на каждый ход:
```
353
1 2 3 4
5 6 7 8
9 10 11 12
13 15 14 0
----------
1 2 3 4
5 6 7 8
9 10 11 12
13 15 0 14
...
...
...
```

 ... либо:
 ``` NO SOLUTION FOR YOUR COMBINATION```


## Что можно улучшить:
- Эвристики (сложно, но можно найти в англоязычных статейках умные варианты)
- При равенстве функций f (эвристических расстояний) очередь с приоритетами работает как стек (LIFO), это зависит от реализации. Можно узнать как в конкретном случае (для пятнашек) это влияет на скорость нахождения решения. И, например, заменить реализацию очереди на свою - FIFO в случае равенства эвристик.
- Для случая из предыдущего пункта получаем:
При LIFO - поиск в глубину,
при FIFO - в ширину.
В зависимости от величины эвристики можем подставлять ту или иную очередь.
Тоесть чем меньше эвристика тем ближе мы к решению, тем выгоднее нам уходить вглубь.
И наоборот, при большой величине эвристической функции интересно посмотреть в ширину, не уменьшается ли она там.


### Годные ссылки и источники
[раз](https://www.cs.princeton.edu/courses/archive/fall12/cos226/assignments/8puzzle.html)

[два](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)

[три](http://book.etudes.ru/toc/15puzzle/)

[поискать на вики]()

[и в гугле]()


## Офтоп
Посмотрим результаты работы профилировщика:
``` bash
python3.5 -m cProfile -s time solver15.py
```
```
5 1 9 3 
11 13 6 8 
14 10 4 15 
0 12 7 2 
1 2 3 4 
5 6 7 8 
9 10 11 12 
13 14 15 0 

         92069971 function calls (92069970 primitive calls) in 53.480 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  1796766   24.731    0.000   48.634    0.000 solver15.py:28(manh_dst)
 28878926   20.555    0.000   24.051    0.000 solver15.py:6(manh_dst_matrix)
 57757852    3.496    0.000    3.496    0.000 {built-in method builtins.abs}
   898383    0.789    0.000   50.037    0.000 solver15.py:65(__lt__)
    39392    0.778    0.000    1.712    0.000 solver15.py:68(get_neighbours)
  1796766    0.614    0.000   49.248    0.000 solver15.py:62(f)
   118045    0.598    0.000    0.682    0.000 solver15.py:23(__init__)
        1    0.553    0.553   53.391   53.391 a_star.py:11(a_star)
   157437    0.480    0.000    0.480    0.000 solver15.py:35(last_node)
    39393    0.363    0.000   30.647    0.001 {built-in method _heapq.heappop}
    75215    0.247    0.000   20.000    0.000 {built-in method _heapq.heappush}
        1    0.088    0.088   53.480   53.480 solver15.py:1(<module>)
   118045    0.066    0.000    0.066    0.000 {built-in method math.sqrt}
   118043    0.051    0.000    0.051    0.000 {method 'copy' of 'list' objects}
    39392    0.030    0.000    0.030    0.000 {method 'index' of 'list' objects}
   118043    0.022    0.000    0.022    0.000 {method 'append' of 'list' objects}
   118049    0.018    0.000    0.018    0.000 {built-in method builtins.len}

```